package foundation

import (
	"reflect"
	"strings"

	"github.com/dr-dobermann/gobpm/pkg/errs"
	"github.com/dr-dobermann/gobpm/pkg/model/options"
)

const (
	PlainText = "text/plain"
)

type (
	// baseConfig holds configuration for BaseElement building
	baseConfig struct {
		id   string
		docs []*Documentation
	}

	// BaseOptions sets one BaseConfig fields
	BaseOption func(*baseConfig) error
)

// Validate implements options.Configurator interface.
func (bc *baseConfig) Validate() error {
	return nil
}

// Apply implements options.Option interface for BaseOption
func (bo BaseOption) Apply(cfg options.Configurator) error {
	if bc, ok := cfg.(*baseConfig); ok {
		return bo(bc)
	}

	return errs.New(
		errs.M("not BaseConfig: %s", reflect.TypeOf(cfg).String()),
		errs.C(errorClass, errs.TypeCastingError))
}

// WithId updates id field in BaseConfig.
func WithId(id string) options.Option {
	f := func(bc *baseConfig) error {
		id = strings.Trim(id, " ")
		if id == "" {
			return errs.New(
				errs.M("empty id isn't allowed (omit WithId to set autogenerated Id)"),
				errs.C(errorClass, errs.EmptyNotAllowed))
		}

		bc.id = id

		return nil
	}

	return BaseOption(f)
}

// WithDocs updates docs element of BaseConfig.
func WithDoc(text, format string) options.Option {
	f := func(bc *baseConfig) error {
		bc.docs = append(bc.docs, newDoc(text, format))

		return nil
	}

	return BaseOption(f)
}

// baseElement creates a new BaseElement from BaseConfig.
func (bc *baseConfig) baseElement() *BaseElement {
	return &BaseElement{
		id:   bc.id,
		docs: bc.docs,
	}
}
