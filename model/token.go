package model

import (
	"io"

	"github.com/google/uuid"
)

type TokenState uint16

const (
	TSLive TokenState = iota
	TSInactive
)

type Token struct {
	id    Id
	pID   Id
	state TokenState
	prevs []*Token
	nexts []*Token
}

func (t Token) ID() Id {
	return t.id
}

func (t Token) State() TokenState {
	return t.state
}

// NewToken creates a new Token with id tID, linked to
// process pID and which has parent p.
// tID could be uuid.Nil, then token id would be autogenerated
// p could be nil so the Token doesn't have any parent.
// If pID is uuid.Nil the nil will be return, since
// there is no reason to have Token without the process.
func NewToken(tID Id, pID Id) *Token {
	if pID == Id(uuid.Nil) {
		return nil
	}

	if tID == Id(uuid.Nil) {
		tID = NewID()
	}

	return &Token{tID, pID, TSLive, []*Token{}, []*Token{}}
}

// Split token onto n new tokens.
// Current token becomes inactive.
// if n == 0 the token itself will be returned with
// Live state.
// Token with inactive status couldn't be splitted and
// Split panics on this enquery
func (t *Token) Split(n uint16) []*Token {
	if t.State() == TSInactive {
		panic("Couldn't split inactive token " + t.ID().String())
	}

	tt := []*Token{}

	if n == 0 {
		return append(tt, t)
	}

	for i := 0; i < int(n); i++ {
		nt := &Token{NewID(), t.pID, TSLive, append([]*Token{}, t), []*Token{}}
		tt = append(tt, nt)
		t.nexts = append(t.nexts, nt)
	}
	t.state = TSInactive

	return tt
}

// func (t *Token) GetPrevious() []*Token {
// 	tt := make([]*Token, len(t.prevs))

// 	copy(tt, t.prevs)

// 	return tt
// }

// Join joins one token to another and returns the first one.
// Only tokens with Live status could be joined.
// if t is Inactive panic will fired.
// if jt is Inactive nothing will be joined
func (t *Token) Join(jt *Token) *Token {
	if t.state == TSInactive {
		panic("Couldn't joint to inactive token")
	}

	if jt.state == TSInactive {
		return t
	}

	jt.nexts = append(t.nexts, t)
	t.prevs = append(t.prevs, jt)
	jt.state = TSInactive

	return t
}

type Persister interface {
	io.Reader
	io.Writer
}
